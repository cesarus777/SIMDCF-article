\section{Интерфейс между языковыми frontend'ами и векторным компилятором}
\label{sec:Interface}

Одним из языков, используемых для разработки программ исполняемых на
видеокартах, является ISPC. ISPC (Implicit SPMD Program Compiler) - язык программирования, являющийся
расширением С и реализующий концепцию SPMD. ISPC также, как и CM, является
языком с раздельным исходным кодом. Изначально целевой архитектурой для данного
языка была только архитектура x86 с векторными расширениями, но позже была
добавлена поддержка для ARM процессоров с расширениями Neon, а также
графических ускорителей Intel.

Программа на языке ISPC является SPMD программой и компилируется для векторов
заранее известной зафиксированной длины. В такой программе могут быть как общие,
так и свои для каждого запущенного потока данные. Общие для всех потоков данные
отмечают как uniform переменные, остальные по умолчанию считаются varying. Таким
образом, получается, что varying переменная по факту является каким-то элементом
вектора и может быть любым из них.

Ниже приведен пример функции на языке ISPC.

\begin{verbatim}
void simple(uniform float vin[],
            uniform float vout[],
            uniform int count) {
    foreach (index = 0 ... count) {
        float v = vin[index];
        if (v < 3.)
            v = v * v;
        else
            v = sqrt(v);
        vout[index] = v;
    }
}
\end{verbatim}

В ISPC нет ограничений на векторный поток управления в
стандартных конструкциях языка, и on реализуется через использование в качестве
условия varying переменной. Но при этом, так как ISPC является языком для
нескольких совершенно разных платформ с совершенно разной архитектурой, в данном
языке невозможно использование зависимых от платформы интринсиков. Вместо этого
ISPC маскирует результаты операций после условных переходов для векторного потока
управления. Безусловным преимуществом такого подхода является
кроссплатформенность достигаемая таким решением, но для архитектуры графических
ускорителей Intel такой подход не позволяет использовать всех векторных
возможностей потока управления аппаратуры.

В связи с этим был предложен интефейс для frontend'ов языков использующих
векторный backend графического компилятора Intel. Так как интерфейс должен
представлять собой конструкцию на промежуточном
представлении LLVM IR, который не поддерживает векторный поток управления,
неизбежно возникает необходимость сводить векторное условие к скалярному виду.
Перед условным переходом необходимо проверить справедливо ли условие хоть для
одного элемента и выполнять переход только в таком случае. Для наибольшей
кроссплатформенности для подобных проверок следует использовать стандартные
интринсики LLVM \texttt{@llvm.vector.reduce.and} и
\texttt{@llvm.vector.reduce.or}. Также для frontend'ов, имеющих только
архитектуру графических ускорителей Intel как
целевую, допускается использовать для редукции условий платформозависимые
интринсики \text{@llvm.genx.any} и \text{@llvm.genx.any}, являющиеся полными
аналогами прежде упомянутых. Для сохранения семантического смысла и
поддержки платформ, на которых нет развитой поддержки векторного потока
управления, необходимо маскировать условием побочные эффекты дуги перехода.

Как не трудно заметить данный подход будет абсолютно валиден для
скалярных архитектур, поддерживающих необходимые минимальные векторные
расширения. При этом в процессе оптимизаций компилятор не сможет сделать
трансформации меняющие смысл контекста, так как такая конструкция будет валидна
на всех этапах своего существования.
